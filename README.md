# PraktikumChatApp

## Как работать с проектом

В проекте есть 3 ветки: master, start, finish

- _master_ – это главная ветка, на которой вы будете находиться при начальном открытии проекта
- _start_ – ветка, в которой содержится начальный код
- _finish_ – ветка, в которой, соответственно, содежится код, который мы должны будет получить после выполнения всех
  заданий

## Задания

Далее представлен гайд, который пошагово, с помощью выполнение тех или иных заданий в проекте _start_, позволит вам
достигнуть результата, представленного в _finish_

Поехали!

### Задание 1

Для начала вам требуется заменить использование LiveData на StateFlow, для оптимизации работы с данными

Сейчас `LiveData` находится внутри `ChatViewModel`, для перевода на StateFlow требуются следующие шаги:

1. Создать `StateFlow<List<String>>` в `ChatViewModel` и удалить использование `LiveData`

```kotlin
private val _messages = MutableStateFlow(emptyList<Message>())
private val messages = _messages.asStateFlow()
```

2. Переписать метод `sendMessage(String)` только теперь с использованием ранее созданного `Flow`

```kotlin
suspend fun sendMyMessage(text: String) {
        _messages.update {
            // логика добавления нового сообщения в _messages
        }
}
```

3. Внутри MainActivity заменить `observeAsState` на `collectAsState` для `messages`

### Задание 2

Потокобезопасность уже обеспечена с помощью использования `StateFlow.update()`. Другие варианты использования
`StateFlow` могут привести к нарушению изначального порядка сообщений


### Задание 3

В этом задании вам требуется написать unit-тест на нашу `ChatViewModel`

1. Для этого откройте файл ChatViewModelTest, в нём уже содержатся необходимые приготовления – мокирование,
   а также два метода для тестов. В этом задании вам нужно работать с методом `send message should update messages with MyMessage`.
   Внутри которого вам нужно написать тест и проверить, что при вызове метода `sendMyMessage` `viewModel.messages`
   будет содержать это сообщение.
2. Также нужно раскоментировать `Dispatchers.setMain` и `Dispatchers.resetMain`, т.к. нам нужно подменить диспатчер,
   который используется внутри `ViewModel` на тестовый.

### Задание 4

В данном задании вы напишите юнит-тест, который проверит потокобезопасность нашей реализации

1. Внутри метода `testReceiveMessage_concurrentMessages` напишите тест по аналогии с тестом из задания 3, но который
   будет одновременно отправлять 100 сообщений из списка `messagesToSend`.
2. Вам здесь пригодится использование extenstion-функции `Collection<Job>.joinAll` для параллельного запуска сразу
   100 добавлений в список сообщений.


### Задание 5

Целью пятого задание является добавление функциональности версионирования для сообщений. Это будет полезно, если
мы добавим новый тип сообщений, который в прошлых версиях приложения поддерживаться не будет, при этом будет приходить
с сервера.

1. Добавьте в корневой класс `Message` `abstract` переменную c название `version` – это позволит нам менять версию
   для каждого типа сообщений отдельно. После добавления вам потребуется переопределить эту переменную в каждом из конструкторов
   класаа для каждого типа сообщений, пока можно поставить значение по умолчанию равное 1.
2. Также для того, чтобы понимать, как максимальную версию поддерживает текущая версия приложения, добавьте константу
   в репозиторий:
```Kotlin
const val MESSAGE_SUPPORTED_VERSION = 1
```
3. Теперь нужно добавить логику отображения в `MainActivity`. Для каждой из карточек сообщений для параметра `text`
   напишите `if` для проверки версии. Если версия сообщения больше, чем максимально поддерживаемая версия, то отобразите
   сообщение-заглушку из `R.string.unsupported_message`. Для проверки реализации, можете выставить `version > 1` для
   `OtherMessage`


### Задание 6

В данном задание вам необходимо написать логику обработки ошибок «сети». Конечно в данном проекте нет никаких запросов
сети, в данном случае ошибки у нас будут «эмулироваться»  в `ChatApi`.

1. Раскомментируйте строчку со случайным бросанием ошибки в `ChatApi`. Теперь, судя по коду, запрос за ответным сообщением
   будет возвращаться с ошибкой с заметной регулярностью.
2. Теперь нужно добавить обработчик в метод `getReplyMessage()`, который будет повторять запрос несколько раз с экспоненциальным увеличением
   тайм-аута. Для этого нам пригодится функция `repeat` внутри, которой, при успешном ответе мы сразу возвращаем его, а
   при получении ошибки, т.е. если выполнение в блоке продолжается после `try-catch`, мы увеличиваем время для `delay`.
3. Чтобы быть уверенным в надёжности данной логики - напишем юнит-тесты, которые будут проверять обработку ошибки и успешное получение.
4. В файле `ChatRepositoryTest` есть два метода - один для проверки успешного ответа, другой для проверки ретрая. Код для
   проверки ретрая уже написан - так вы можете проверить, что логика реализованная вами в репозитории, работает правильно.
   Напишите по аналогии тест для проверки успешного ответа без ретрая.




