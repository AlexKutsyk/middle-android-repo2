# PraktikumChatApp

## Для ревьюров

В проекте есть 2 ветки: start, finish

- _start_ – ветка, в которой содержится начальный код
- _finish_ – ветка, в которой, соответственно, содежится код, который мы должны будет получить после выполнения всех
  заданий

## Задания

Вам требуется последовательно выполнить задания проекта, чтобы прийти от старта к финишу - где-то нужно будет
отрефакторить уже существующий код, где-то написать новый с нуля, либо раскомментировать нужный фрагмент.

Поехали!

### Задание 1

Для начала вам требуется заменить использование LiveData на StateFlow, для оптимизации работы с данными

Сейчас `LiveData` находится внутри `ChatViewModel`, для перевода на StateFlow требуются следующие шаги:

1. Создать `StateFlow<List<String>>` в `ChatViewModel` и удалить использование `LiveData`

```kotlin
private val _messages = MutableStateFlow(emptyList<Message>())
private val messages = _messages.asStateFlow()
```

2. Переписать метод `sendMessage(String)` только теперь с использованием ранее созданного `Flow`

```kotlin
suspend fun sendMyMessage(text: String) {
   _messages.update {
      // логика добавления нового сообщения в _messages
   }
}
```

3. Внутри MainActivity заменить `observeAsState` на `collectAsState` для `messages`

### Задание 2

В этом задании вам требуется написать unit-тест на нашу `ChatViewModel`

1. Для этого откройте файл ChatViewModelTest, в нём уже содержатся необходимые приготовления – мокирование,
   а также два метода для тестов. В этом задании вам нужно работать с методом
   `send message should update messages with MyMessage`.
   Внутри которого вам нужно написать тест и проверить, что при вызове метода `sendMyMessage` `viewModel.messages`
   будет содержать это сообщение.
2. Также нужно раскоментировать `Dispatchers.setMain` и `Dispatchers.resetMain`, т.к. нам нужно подменить диспатчер,
   который используется внутри `ViewModel` на тестовый.

### Задание 3

В данном задании вы напишите юнит-тест, который проверит потокобезопасность нашей реализации.

Внутри метода `testReceiveMessage_concurrentMessages` напишите тест по аналогии с тестом из задания 2,
но который будет одновременно отправлять 100 сообщений из списка messagesToSend.

<details><summary>Подсказка</summary>
Вам нужно запустить несколько корутин одновременно. Как это сделать?

Создать `coroutineScope` внутри теста и для каждого сообщения сделать fire-and-forget корутину. Этого можно добиться
через корутин-билдер `launch {}`
Также мы должны дождаться окончания их выполнения.
Здесь пригодится использование extension-функции `Collection<Job>.joinAll` для параллельного запуска сразу 100
добавлений
в список сообщений.

Далее мы должны проверить количество сообщений и их содержание.
</details>

### Задание 4

В данном задание вам необходимо написать логику обработки ошибок «сети». Конечно в данном проекте нет никаких запросов
сети, в данном случае ошибки у нас будут «эмулироваться» в `ChatApi`.

1. Раскомментируйте строчку со случайным бросанием ошибки в `ChatApi`. Теперь, судя по коду, запрос за ответным
   сообщением
   будет возвращаться с ошибкой с заметной регулярностью.
2. Добавьте обработчик в метод `getReplyMessage()` из класса `ChatRepository`, который будет повторять запрос несколько
   раз
   с экспоненциальным увеличением тайм-аута. Для этого пригодится функция `retryWhen`, в которой вы должны написать
   условие на проверку ошибки и в случае ошибки вызывать `delay` с заданным временем задержки, после которого нужно
   увеличивать время задержки.
   Пример кода:

```
   if (exception != null) {
      delay(currentDelay)
      currentDelay *= DELAY_FACTOR
   }
````

3. Чтобы быть уверенным в надёжности данной логики - напишем юнит-тесты, которые будут проверять обработку ошибки и
   успешное получение. В файле `ChatRepositoryTest` есть два метода - один для проверки успешного ответа, другой для
   проверки ретрая. Код
   для
   проверки ретрая уже написан - так вы можете проверить, что логика реализованная вами в репозитории, работает
   правильно.
   Напишите по аналогии тест для проверки успешного ответа без ретрая.




